// Prisma schema for CRM Subscription Plans and Monetization
// Provider: PostgreSQL (Neon)

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// --- RBAC Users ---
enum Role {
  SUPER_ADMIN
  ADMIN
  MANAGER
  OWNER
  VENDOR
  TENANT
}

model User {
  id                     String         @id @default(cuid())
  email                  String         @unique
  name                   String?
  role                   Role           @default(TENANT)
  permissions            String?
  autopayEnabled         Boolean        @default(false)
  stripeCustomerId       String?
  defaultPaymentMethodId String?
  orgId                  String
  org                    Organization   @relation(fields: [orgId], references: [id])
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt

  @@index([orgId])
}

model Organization {
  id        String        @id @default(cuid())
  name      String
  plan      String        @default("basic")
  users     User[]
  settings  OrgSettings?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
}

model OrgSettings {
  id                 String        @id @default(cuid())
  orgId              String        @unique
  exportSchedule     String        @default("daily")
  allowImpersonation Boolean       @default(false)
  organization       Organization  @relation(fields: [orgId], references: [id])
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
}

model ImpersonationLog {
  id             String   @id @default(cuid())
  superAdminId   String?
  adminId        String?
  targetUserId   String
  startedAt      DateTime @default(now())
  endedAt        DateTime?
  notified       Boolean  @default(false)
}

model UserNotification {
  id        String   @id @default(cuid())
  userId    String
  message   String
  type      String?
  title     String?
  meta      Json?
  createdAt DateTime @default(now())
  read      Boolean  @default(false)
}

enum BillingCycle {
  monthly
  yearly
}

enum ProductType {
  product
  addon
  service
  subscription
}

enum SubscriptionStatus {
  active
  trialing
  past_due
  canceled
  incomplete
  incomplete_expired
  unpaid
  paused
}

model SubscriptionPlan {
  id            String       @id @default(uuid())
  name          String
  price         Float        @default(0)
  billingCycle  BillingCycle @default(monthly)
  description   String?
  userLimit     Int          @default(1)
  propertyLimit Int          @default(10)
  isActive      Boolean      @default(true)
  features      String[]
  pages         String[]
  tools         String[]
  services      String[]
  paymentTypes  String[]
  backupTypes   String[]
  subscriptions Subscription[]
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

model Product {
  id          String      @id @default(uuid())
  name        String
  description String?
  type        ProductType @default(product)
  price       Float       @default(0)
  isActive    Boolean     @default(true)
  category    String?
  tags        String[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model Subscriber {
  id          String         @id @default(uuid())
  email       String         @unique
  companyName String?
  subscriptions Subscription[]
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}

model Subscription {
  id                   String              @id @default(uuid())
  subscriberId         String
  subscriber           Subscriber          @relation(fields: [subscriberId], references: [id])
  planId               String?
  plan                 SubscriptionPlan?   @relation(fields: [planId], references: [id])
  status               SubscriptionStatus  @default(active)
  startDate            DateTime            @default(now())
  endDate              DateTime?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  cancelAtPeriodEnd    Boolean             @default(false)
  payments             Payment[]
  revenueEvents        RevenueEvent[]
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
}

model Payment {
  id             String        @id @default(uuid())
  subscriptionId String
  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  amount         Float
  currency       String        @default("usd")
  status         String
  provider       String        @default("stripe")
  externalId     String?
  createdAt      DateTime      @default(now())
}

model RevenueEvent {
  id             String        @id @default(uuid())
  subscriptionId String?
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  type           String
  amount         Float
  metadata       Json?
  createdAt      DateTime      @default(now())
}

// --- Tenant Rent Payments ---
model RentPayment {
  id              String   @id @default(cuid())
  tenantId        String
  propertyId      String?
  leaseId         String?
  amount          Float
  allocatedAmount Float   @default(0)
  status          String   // pending | success | failed | refunded | partially_refunded
  gateway         String   // stripe | paypal | plaid | applepay
  methodId        String?
  externalId      String?
  idempotencyKey  String?  @unique
  refundedAmount  Float    @default(0)
  autopay         Boolean  @default(false)
  refundReason    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tenant       User      @relation(fields: [tenantId], references: [id])
  property     Property? @relation(fields: [propertyId], references: [id])
  lease        Lease?    @relation(fields: [leaseId], references: [id])
  allocations  PaymentAllocation[]

  @@index([tenantId])
  @@index([propertyId])
  @@index([leaseId])
}

model LateFeeRule {
  id          String   @id @default(cuid())
  scope       String   // GLOBAL | PROPERTY
  propertyId  String?
  gracePeriod Int
  feeType     String   // FIXED | PERCENTAGE
  feeAmount   Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  property    Property? @relation(fields: [propertyId], references: [id])

  @@index([isActive])
  @@index([propertyId])
}

model LateFee {
  id         String   @id @default(cuid())
  tenantId   String
  paymentId  String?
  propertyId String
  amount     Float
  status     String   // PENDING | APPLIED | WAIVED
  appliedAt  DateTime?
  waivedBy   String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant     User       @relation(fields: [tenantId], references: [id])
  payment    RentPayment? @relation(fields: [paymentId], references: [id])
  property   Property   @relation(fields: [propertyId], references: [id])

  @@index([tenantId])
  @@index([propertyId])
  @@index([paymentId])
}

model Refund {
  id         String   @id @default(cuid())
  paymentId  String
  tenantId   String
  amount     Float
  status     String   // PENDING | COMPLETED | FAILED
  reason     String?
  gateway    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant     User        @relation(fields: [tenantId], references: [id])
  payment    RentPayment @relation(fields: [paymentId], references: [id])

  @@index([tenantId])
  @@index([paymentId])
}

model AutoPay {
  id         String   @id @default(cuid())
  tenantId   String   @unique
  amount     Float
  frequency  String
  dayOfMonth Int
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // New fields for gateway-scoped rules
  propertyId  String?
  gatewayId   String?
  methodId    String?
  amountType  String?   @default("FULL_RENT") // FULL_RENT | FIXED | PERCENTAGE
  amountValue Float?

  tenant     User     @relation(fields: [tenantId], references: [id])
  property   Property? @relation(fields: [propertyId], references: [id])

  @@index([propertyId])
}

/// ----------------------------------------------------------
///  NEW MODELS FOR TENANT‑LEDGER / PAST BALANCES
/// ----------------------------------------------------------

enum LeaseStatus {
  ACTIVE
  TERMINATED   // tenant moved out but balance may still exist
  CLOSED       // all balances settled, can be archived
}

enum EntryType {
  RENT
  DEPOSIT
  FEE
  PAYMENT
  ADJUSTMENT
}

model Property {
  id        String   @id @default(uuid())
  address   String
  units     Unit[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model SLAConfig {
  id         String    @id @default(cuid())
  category   String
  hours      Int
  propertyId String?

  property   Property? @relation(fields: [propertyId], references: [id])

  @@index([category])
  @@index([propertyId])
  @@unique([category, propertyId])
}

model EscalationMatrix {
  id                 String   @id @default(cuid())
  level              Int
  role               String
  hoursAfterDeadline Int

  // Scope
  propertyId         String?
  subscriptionPlanId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  property          Property?         @relation(fields: [propertyId], references: [id])
  subscriptionPlan  SubscriptionPlan? @relation(fields: [subscriptionPlanId], references: [id])

  @@index([propertyId])
  @@index([subscriptionPlanId])
  @@unique([level, propertyId, subscriptionPlanId])
}

model OwnerLedger {
  id         String    @id @default(cuid())
  ownerId    String
  propertyId String?
  entryType  String    // rent_income, expense, fee, refund
  amount     Float
  note       String?
  createdAt  DateTime  @default(now())

  owner      User      @relation(fields: [ownerId], references: [id])
  property   Property? @relation(fields: [propertyId], references: [id])

  @@index([ownerId])
  @@index([propertyId])
}

model Unit {
  id         String   @id @default(uuid())
  number     String
  propertyId String
  property   Property @relation(fields: [propertyId], references: [id])
  leases     Lease[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([propertyId])
  @@unique([propertyId, number])
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  email     String?
  leases    Lease[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Lease {
  id            String        @id @default(uuid())
  unitId        String
  tenantId      String
  orgId         String?
  startDate     DateTime
  endDate       DateTime?
  status        LeaseStatus   @default(ACTIVE)
  archived      Boolean       @default(false)   // hide from active UI if desired
  rentAmount    Float?
  dueDay        Int?          // 1..31, day of the month rent is due
  unit          Unit          @relation(fields: [unitId], references: [id])
  tenant        Tenant        @relation(fields: [tenantId], references: [id])
  ledgerEntries LedgerEntry[]
  allowSplit    Boolean       @default(true)
  allowPartial  Boolean       @default(true)
  minPartialUsd Float?

  participants  LeaseParticipant[]
  invoices      Invoice[]
  payments      RentPayment[]

  @@index([status])                     // fast lookup of terminated leases
  @@index([tenantId])
  @@index([unitId])
}

model LedgerEntry {
  id          String    @id @default(uuid())
  leaseId     String
  lease       Lease     @relation(fields: [leaseId], references: [id])
  date        DateTime  @default(now())
  description String
  amountCents Int       // positive = charge, negative = payment
  type        EntryType

  @@index([leaseId])
}

// --- Recurring maintenance automation ---
enum RecurrenceFrequency {
  DAY
  WEEK
  MONTH
  QUARTER
  YEAR
}

model RecurringTask {
  id          String               @id @default(cuid())
  propertyId  String
  unitId      String?
  title       String
  description String?
  frequency   RecurrenceFrequency
  interval    Int                  @default(1)
  nextRunAt   DateTime
  lastRunAt   DateTime?
  vendorId    String?
  isActive    Boolean              @default(true)
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  property    Property             @relation(fields: [propertyId], references: [id])
  unit        Unit?                @relation(fields: [unitId], references: [id])

  @@index([propertyId])
  @@index([unitId])
  @@index([isActive, nextRunAt])
}

model MaintenanceRequest {
  id          String   @id @default(cuid())
  tenantId    String?
  orgId       String?
  propertyId  String
  unitId      String?
  title       String
  description String?
  category    String?
  status      String   @default("open") // open, in_progress, completed, canceled
  priority    String   @default("normal")  // low, normal, high, emergency
  assignedTo  String?
  vendorId    String?
  createdById String?
  deadline    DateTime?
  escalated   Boolean  @default(false)
  escalatedAt DateTime?
  escalationLevel Int  @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  property    Property @relation(fields: [propertyId], references: [id])
  unit        Unit?    @relation(fields: [unitId], references: [id])
  attachments MaintenanceAttachment[]
  assignments MaintenanceAssignment[]

  @@index([propertyId])
  @@index([unitId])
  @@index([status])
  @@index([orgId])
  @@index([tenantId])
  @@index([deadline])
  @@index([escalated])
}

/// Document Management System
model Document {
  id          String        @id @default(cuid())
  orgId       String
  uploadedBy  String
  tenantId    String?
  leaseId     String?
  type        String
  name        String
  url         String
  createdAt   DateTime      @default(now())

  org         Organization  @relation(fields: [orgId], references: [id])
  uploader    User          @relation(fields: [uploadedBy], references: [id])
  tenant      Tenant?       @relation(fields: [tenantId], references: [id])
  lease       Lease?        @relation(fields: [leaseId], references: [id])

  @@index([orgId])
  @@index([tenantId])
  @@index([leaseId])
  @@index([uploadedBy])
}

model MaintenanceAttachment {
  id         String   @id @default(cuid())
  requestId  String
  fileUrl    String
  fileName   String
  fileType   String
  uploadedAt DateTime @default(now())
  archivedAt DateTime?

  request    MaintenanceRequest @relation(fields: [requestId], references: [id])

  @@index([requestId])
}

model MaintenanceAssignment {
  id          String   @id @default(cuid())
  requestId   String
  assigneeId  String
  role        String   // manager | vendor | staff
  assignedAt  DateTime @default(now())
  completedAt DateTime?

  request     MaintenanceRequest @relation(fields: [requestId], references: [id])

  @@index([requestId])
  @@index([assigneeId])
}

model EscalationLog {
  id          String   @id @default(cuid())
  requestId   String
  level       Int
  role        String
  triggeredAt DateTime @default(now())

  request     MaintenanceRequest @relation(fields: [requestId], references: [id])

  @@unique([requestId, level])
  @@index([requestId])
}

model MaintenanceInvoice {
  id         String   @id @default(cuid())
  requestId  String
  vendorId   String
  amount     Float?
  status     String   @default("pending") // pending, approved, rejected
  uploadedAt DateTime @default(now())
  archivedAt DateTime?

  request    MaintenanceRequest @relation(fields: [requestId], references: [id])
  vendor     User               @relation(fields: [vendorId], references: [id])
  files      InvoiceFile[]

  @@index([requestId])
  @@index([vendorId])
}

model InvoiceFile {
  id         String   @id @default(cuid())
  invoiceId  String
  fileUrl    String
  fileName   String
  fileType   String
  uploadedAt DateTime @default(now())
  archivedAt DateTime?

  invoice    MaintenanceInvoice @relation(fields: [invoiceId], references: [id])

  @@index([invoiceId])
}

model DirectMessage {
  id          String   @id @default(cuid())
  senderId    String
  receiverId  String?
  propertyId  String?
  content     String
  isRead      Boolean  @default(false)
  createdAt   DateTime @default(now())

  sender      User     @relation("DirectMessagesSent", fields: [senderId], references: [id])
  receiver    User?    @relation("DirectMessagesReceived", fields: [receiverId], references: [id])
  property    Property? @relation(fields: [propertyId], references: [id])
  attachments DirectMessageAttachment[]

  @@index([receiverId])
  @@index([propertyId])
}

model DirectMessageAttachment {
  id         String   @id @default(cuid())
  messageId  String
  url        String
  filename   String
  mimeType   String
  createdAt  DateTime @default(now())

  message    DirectMessage @relation(fields: [messageId], references: [id])

  @@index([messageId])
}

// --- Platform Notifications ---
model Notification {
  id        String   @id @default(cuid())
  title     String
  message   String
  audience  String   // ALL, ADMINS, TENANTS, OWNERS...
  createdBy String
  createdAt DateTime @default(now())
}

// --- Accounting integrations ---
model AccountingConnection {
  id           String   @id @default(cuid())
  orgId        String
  provider     String   // quickbooks | xero | freshbooks
  realmId      String?
  accessToken  String
  refreshToken String
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  enabled      Boolean  @default(true)

  @@unique([orgId, provider])
}

model AccountingSyncLog {
  id        String   @id @default(cuid())
  orgId     String
  provider  String
  direction String   // push | pull
  entity    String   // ledger_entry | account | invoice | bill | payment
  payload   Json
  status    String   // success | failed | pending
  message   String?
  createdAt DateTime @default(now())
}

model COAMap {
  id           String   @id @default(cuid())
  orgId        String
  provider     String   // quickbooks | xero | freshbooks
  localType    String   // rent_income | expense | fee | refund | security_deposit
  providerAcct String
  updatedAt    DateTime @updatedAt

  @@unique([orgId, provider, localType])
}

model SyncQueue {
  id        String   @id @default(cuid())
  orgId     String
  provider  String
  task      String   // push_ledger_entry | pull_accounts | reconcile
  payload   Json
  retries   Int      @default(0)
  notBefore DateTime @default(now())
  createdAt DateTime @default(now())
}

// --- Payment Methods ---
model PaymentMethod {
  id         String   @id @default(cuid())
  tenantId   String
  provider   String   // "stripe", "paypal", etc.
  methodId   String   // provider method ID
  type       String   // "card", "ach"
  last4      String?
  brand      String?
  isDefault  Boolean  @default(false)
  createdAt  DateTime @default(now())

  tenant User @relation(fields: [tenantId], references: [id])
}

// --- Payment Receipt Audit Log ---
model PaymentReceipt {
  id        String   @id @default(cuid())
  paymentId String
  tenantId  String
  type      String   // email | sms
  status    String   // sent | failed
  createdAt DateTime @default(now())
}

// --- Global / Property Payment Settings ---
model GlobalPaymentSetting {
  id          String   @id @default(cuid())
  dueDay      Int      @default(1)    // rent due date (e.g., 1st of month)
  gracePeriod Int      @default(3)    // days after due date
  lateFee     Float    @default(50.0) // default fee
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model PropertyPaymentSetting {
  id          String   @id @default(cuid())
  propertyId  String   @unique
  dueDay      Int?
  gracePeriod Int?
  lateFee     Float?

  property    Property @relation(fields: [propertyId], references: [id])
}

// --- Payment Compliance ---
model PaymentAudit {
  id        String   @id @default(cuid())
  paymentId String?
  tenantId  String?
  action    String   // payment_created | refund_issued | late_fee_applied | dispute_opened | dispute_resolved
  details   String?
  actorId   String?
  createdAt DateTime @default(now())
}

model PaymentDispute {
  id         String   @id @default(cuid())
  paymentId  String
  status     String   // open | under_review | resolved
  reason     String?
  openedAt   DateTime @default(now())
  resolvedAt DateTime?
}

model PaymentGateway {
  id                 String   @id @default(cuid())
  name               String
  enabled            Boolean  @default(false)
  config             Json
  propertyId         String?
  subscriptionPlanId String?
  global             Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  property           Property?         @relation(fields: [propertyId], references: [id])
  subscriptionPlan   SubscriptionPlan? @relation(fields: [subscriptionPlanId], references: [id])

  @@index([propertyId])
  @@index([subscriptionPlanId])
  @@index([global])
}

// --- Messaging ---
model MessageThread {
  id           String               @id @default(cuid())
  subject      String
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  messages     Message[]
  participants MessageParticipant[]
}

model MessageEscalation {
  id        String   @id @default(cuid())
  threadId  String
  fromRole  String
  toRole    String
  reason    String?
  createdAt DateTime @default(now())

  thread    MessageThread @relation(fields: [threadId], references: [id])

  @@index([threadId])
}

model ArchivedThread {
  id         String   @id @default(cuid())
  threadId   String   @unique
  archivedBy String
  archivedAt DateTime @default(now())
  reason     String?

  thread     MessageThread @relation(fields: [threadId], references: [id])
}

model Message {
  id        String   @id @default(cuid())
  threadId  String
  senderId  String
  body      String
  createdAt DateTime @default(now())

  thread      MessageThread       @relation(fields: [threadId], references: [id])
  sender      User                @relation(fields: [senderId], references: [id])
  attachments MessageAttachment[]
  reads       MessageRead[]

  @@index([threadId])
  @@index([senderId])
}

model MessageParticipant {
  id        String   @id @default(cuid())
  threadId  String
  userId    String
  role      String   // tenant, manager, owner, admin, superadmin
  joinedAt  DateTime @default(now())

  thread    MessageThread @relation(fields: [threadId], references: [id])
  user      User          @relation(fields: [userId], references: [id])

  @@unique([threadId, userId])
  @@index([userId])
}

model MessageNotification {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  type      String   // email | sms | inapp
  status    String   // sent | failed | unread | read
  createdAt DateTime @default(now())

  message   Message @relation(fields: [messageId], references: [id])
  user      User    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([messageId])
}

model MessageAttachment {
  id         String   @id @default(cuid())
  messageId  String
  fileUrl    String
  fileType   String
  fileName   String
  uploadedAt DateTime @default(now())

  message    Message  @relation(fields: [messageId], references: [id])

  @@index([messageId])
}

model MessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message   Message @relation(fields: [messageId], references: [id])
  user      User    @relation(fields: [userId], references: [id])

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

// --- Payment policy per Property (global defaults can be row with propertyId = null)
model PropertyPaymentPolicy {
  id            String   @id @default(cuid())
  propertyId    String?  @unique
  allowPartial  Boolean  @default(true)
  allowSplit    Boolean  @default(true)
  minPartialUsd Float    @default(10)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// --- Lease participants (roommates / co-tenants)
model LeaseParticipant {
  id         String  @id @default(cuid())
  leaseId    String
  tenantId   String
  shareType  String  // "EQUAL" | "PERCENTAGE" | "FIXED"
  shareValue Float?  // null for EQUAL, percent for PERCENTAGE (0..100), fixed $ for FIXED

  lease   Lease @relation(fields: [leaseId], references: [id], onDelete: Cascade)

  @@unique([leaseId, tenantId])
}

// --- Invoices (monthly rent, utilities, etc.)
model Invoice {
  id          String   @id @default(cuid())
  leaseId     String
  propertyId  String
  dueDate     DateTime
  totalAmount Float
  balanceDue  Float    @default(0)
  status      String   // "OPEN" | "PARTIALLY_PAID" | "PAID" | "VOID"
  memo        String?

  lines    InvoiceLine[]
  payments PaymentAllocation[]

  lease    Lease    @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([leaseId])
  @@index([propertyId])
  @@index([status])
}

model InvoiceLine {
  id            String   @id @default(cuid())
  invoiceId     String
  description   String
  amount        Float
  billToTenantId String?

  invoice  Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
}

// --- Allocation (where a payment’s dollars actually went)
model PaymentAllocation {
  id         String  @id @default(cuid())
  paymentId  String
  invoiceId  String
  tenantId   String?
  amount     Float

  payment RentPayment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  invoice Invoice      @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([invoiceId])
  @@index([paymentId])
  @@index([tenantId])
}
